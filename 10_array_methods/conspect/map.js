// Метод map() позволяет трансформировать один массив в другой при помощи функций-колбэка.
// Переданная функция будет вызвана для каждого элемента массива по порядку. Из результатов вызова функции будет собран новый массив.




// callbackFnвызывается только для индексов массива, которым присвоены значения. Он не вызывается для пустых ячеек в разреженных массивах .

// Метод map()является методом копирования . Это не меняет this. Однако предоставленная функция as callbackFnможет изменять массив.
// Однако обратите внимание, что длина массива сохраняется до первого вызова callbackFn. Поэтому:

// callbackFnне будет посещать какие-либо элементы, добавленные за пределы начальной длины массива, когда map()начался вызов.
// Изменения в уже посещенных индексах не приводят callbackFnк их повторному вызову.
// Если существующий, еще не посещенный элемент массива изменен callbackFn, его значение, переданное в,
// callbackFnбудет значением на момент посещения этого элемента. Удаленные элементы не посещаются.

const array1 = [1, 4, 9, 16];

// Pass a function to map
const map1 = array1.map((x) => x * 2);

console.log(map1);
// Expected output: Array [2, 8, 18, 32]


// Следующий код принимает массив чисел и создает новый массив, содержащий квадратные корни чисел в первом массиве.
const numbers = [1, 4, 9];
const roots = numbers.map((num) => Math.sqrt(num));

// roots is now     [1, 2, 3]
// numbers is still [1, 4, 9]

// Следующий код показывает, как mapработает функция, требующая одного аргумента.
// Аргумент будет автоматически присвоен каждому элементу массива при mapпроходе по исходному массиву.
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);

console.log(doubles); // [2, 8, 18]
console.log(numbers); // [1, 4, 9]